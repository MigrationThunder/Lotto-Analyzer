<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lotto-Analyzer</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body {
            background: linear-gradient(135deg, #0d0d1b 0%, #1f2a44 100%);
            color: #e0e0e0;
            font-family: 'Orbitron', sans-serif;
            margin: 0;
            padding: 0;
            min-height: 100vh;
            overflow-x: hidden;
            background-image: url('data:image/svg+xml,%3Csvg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath d="M0 0 L100 100 M100 0 L0 100" stroke="rgba(255,0,204,0.1)" stroke-width="1"/%3E%3C/svg%3E');
            background-size: 50px 50px;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 20px;
            width: 95%;
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
        }
        .panel {
            background: rgba(20, 20, 40, 0.85);
            backdrop-filter: blur(15px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 204, 0.3);
            border: 1px solid rgba(255, 0, 204, 0.4);
            transition: transform 0.3s;
        }
        .panel:hover {
            transform: scale(1.02);
        }
        h1 {
            font-size: 2.5em;
            font-weight: 900;
            background: linear-gradient(90deg, #00f7ff, #ff00cc);
            -webkit-background-clip: text;
            color: transparent;
            text-align: center;
            margin: 0 0 20px;
            text-transform: uppercase;
            animation: glitch 2s infinite;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
        }
        button {
            background: linear-gradient(45deg, #00f7ff, #ff00cc);
            border: none;
            padding: 12px 25px;
            border-radius: 30px;
            color: #fff;
            font-size: 1em;
            font-weight: 700;
            cursor: pointer;
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
            box-shadow: 0 0 15px rgba(255, 0, 204, 0.5);
        }
        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 0 25px rgba(0, 255, 204, 0.8);
        }
        button::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s ease, height 0.6s ease;
        }
        button:hover::before {
            width: 200px;
            height: 200px;
        }
        #lottoList, #botRecommendations, #analysisPanel {
            max-height: 500px;
            overflow-y: auto;
            padding: 15px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.05);
        }
        .lotto-entry, .recommendation {
            padding: 15px;
            margin: 8px 0;
            background: linear-gradient(135deg, rgba(255, 0, 204, 0.2), rgba(0, 255, 204, 0.2));
            border-radius: 10px;
            font-size: 1em;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.5);
            transition: all 0.3s;
        }
        .lotto-entry:hover, .recommendation:hover {
            transform: translateX(5px);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
        }
        canvas {
            max-width: 100%;
            margin: 15px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
        }
        th, td {
            padding: 10px;
            text-align: center;
            border: 1px solid rgba(255, 0, 204, 0.3);
        }
        th {
            background: rgba(255, 0, 204, 0.4);
        }
        .loading-bar {
            width: 100%;
            height: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
            display: none;
        }
        .loading-progress {
            width: 0;
            height: 100%;
            background: linear-gradient(90deg, #00f7ff, #ff00cc);
            transition: width 2s ease-in-out;
        }
        .ticker {
            position: fixed;
            bottom: 10px;
            left: 0;
            width: 100%;
            background: rgba(20, 20, 40, 0.9);
            padding: 5px;
            font-size: 0.9em;
            overflow: hidden;
            white-space: nowrap;
            box-shadow: 0 -5px 15px rgba(0, 255, 204, 0.3);
        }
        .ticker span {
            display: inline-block;
            padding-left: 100%;
            animation: marquee 20s linear infinite;
        }
        @keyframes marquee {
            0% { transform: translateX(0); }
            100% { transform: translateX(-100%); }
        }
        @keyframes glitch {
            0% { transform: translate(0); }
            20% { transform: translate(-2px, 2px); }
            40% { transform: translate(2px, -2px); }
            60% { transform: translate(-2px, 0); }
            80% { transform: translate(2px, 0); }
            100% { transform: translate(0); }
        }
        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; }
            h1 { font-size: 2em; }
            button { padding: 10px 20px; font-size: 0.9em; }
            .recommendation { font-size: 0.9em; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="panel">
            <h1>Lotto-Analyzer</h1>
            <div class="button-group">
                <button onclick="fetchAllLottoData()">데이터 가져오기</button>
                <button onclick="updateLatestLotto()">최신 업데이트</button>
                <button onclick="analyzeFrequency()">빈도 분석</button>
                <button onclick="analyzeEvenOdd()">짝/홀 분석</button>
                <button onclick="analyzeSum()">합계 분석</button>
                <button onclick="analyzeRange()">범위 분석</button>
                <button onclick="analyzeConsecutive()">연속 분석</button>
                <button onclick="recommendNumbers()">기본 추천</button>
                <button onclick="advancedAnalysis()">고급 분석</button>
                <button onclick="compareStrategies()">전략 비교</button>
                <button onclick="botRecommend()">로또 번호 추천</button>
                <button onclick="displayLottoData()">데이터 목록</button>
            </div>
        </div>
        <div class="panel" id="lottoList"></div>
        <div class="panel" id="botRecommendations">
            <h1 style="font-size: 1.5em;">Bot Recommendations</h1>
            <div class="loading-bar" id="loadingBar">
                <div class="loading-progress" id="loadingProgress"></div>
            </div>
            <div id="botOutput"></div>
        </div>
    </div>
    <div class="ticker">
        <span>Data-Driven Lotto Analysis - Powered by xAI - Cyberpunk Edition</span>
    </div>

    <script>
        let lottoData = [];
        let currentChart = null;

        // 로컬 스토리지에서 데이터 로드
        try {
            const storedData = localStorage.getItem('lottoData');
            if (storedData) {
                const parsedData = JSON.parse(storedData);
                lottoData = Array.isArray(parsedData) ? parsedData : [];
            }
        } catch (error) {
            console.error('로컬 스토리지 데이터 로드 실패:', error.message);
            lottoData = [];
            localStorage.setItem('lottoData', JSON.stringify(lottoData));
        }

        // 데이터 표시 함수
        function displayLottoData() {
            const lottoList = document.getElementById('lottoList');
            lottoList.innerHTML = '';
            if (currentChart) currentChart.destroy();
            if (!Array.isArray(lottoData) || lottoData.length === 0) {
                lottoList.textContent = '데이터가 없습니다. "데이터 가져오기"를 실행하세요.';
                return;
            }
            lottoData.forEach(entry => {
                const div = document.createElement('div');
                div.className = 'lotto-entry';
                div.textContent = `${entry.drwNo}회차 (${entry.drwNoDate}): ${entry.numbers.join(', ')} (보너스: ${entry.bnusNo})`;
                lottoList.appendChild(div);
            });
        }

        // API 호출 함수
        async function fetchLottoData(drwNo, retries = 3) {
            const url = `https://api.allorigins.win/get?url=${encodeURIComponent(`https://www.dhlottery.co.kr/common.do?method=getLottoNumber&drwNo=${drwNo}`)}`;
            for (let attempt = 0; attempt < retries; attempt++) {
                try {
                    const response = await fetch(url);
                    if (!response.ok) {
                        console.error(`회차 ${drwNo} 요청 실패: ${response.status}`);
                        if (response.status === 429) {
                            await new Promise(resolve => setTimeout(resolve, 10000));
                            continue;
                        }
                        return null;
                    }
                    const data = await response.json();
                    const contents = JSON.parse(data.contents);
                    if (contents.returnValue === 'success') {
                        return {
                            drwNo: contents.drwNo,
                            drwNoDate: contents.drwNoDate,
                            numbers: [contents.drwtNo1, contents.drwtNo2, contents.drwtNo3, contents.drwtNo4, contents.drwtNo5, contents.drwtNo6],
                            bnusNo: contents.bnusNo
                        };
                    } else {
                        console.log(`회차 ${drwNo}: 데이터 없음`);
                        return null;
                    }
                } catch (error) {
                    console.error(`회차 ${drwNo} 실패: ${error.message}`);
                    if (attempt < retries - 1) await new Promise(resolve => setTimeout(resolve, 5000));
                }
            }
            return null;
        }

        // 최신 회차 번호 동적 확인
        async function getLatestDrwNo() {
            const maxDrwNo = 1200;
            let latestDrwNo = 0;
            const latestStored = lottoData.length > 0 ? Math.max(...lottoData.map(d => d.drwNo)) : 0;
            let start = latestStored > 0 ? latestStored : 1000;

            for (let i = start; i <= maxDrwNo; i += 10) {
                const data = await fetchLottoData(i);
                if (data) {
                    latestDrwNo = i;
                } else {
                    for (let j = i - 1; j >= start; j--) {
                        const lastData = await fetchLottoData(j);
                        if (lastData) return j;
                    }
                    break;
                }
                await new Promise(resolve => setTimeout(resolve, 1000));
            }
            return latestDrwNo > 0 ? latestDrwNo : start;
        }

        // 모든 회차 가져오기
        async function fetchAllLottoData() {
            const latestDrwNo = await getLatestDrwNo();
            const batchSize = 20;
            const existingDrwNos = new Set(lottoData.map(d => d.drwNo));
            let failedAttempts = 0;
            const maxAttempts = 5;

            for (let start = 1; start <= latestDrwNo; start += batchSize) {
                const end = Math.min(start + batchSize - 1, latestDrwNo);
                for (let i = start; i <= end; i++) {
                    if (!existingDrwNos.has(i)) {
                        const data = await fetchLottoData(i);
                        if (data) {
                            lottoData.push(data);
                            existingDrwNos.add(i);
                            console.log(`${i}회차 완료`);
                            failedAttempts = 0;
                        } else {
                            failedAttempts++;
                            if (failedAttempts >= maxAttempts) {
                                alert(`연속 ${maxAttempts}회 실패. ${i-1}회차까지 완료`);
                                break;
                            }
                        }
                    }
                    await new Promise(resolve => setTimeout(resolve, 3000));
                }
                if (failedAttempts >= maxAttempts) break;
            }

            lottoData.sort((a, b) => a.drwNo - b.drwNo);
            localStorage.setItem('lottoData', JSON.stringify(lottoData));
            displayLottoData();
            alert(`데이터 가져오기 완료! (최신: ${latestDrwNo}회차)`);
        }

        // 최신 회차 업데이트
        async function updateLatestLotto() {
            const latestStored = lottoData.length > 0 ? Math.max(...lottoData.map(d => d.drwNo)) : 0;
            const maxDrwNo = 1200;
            const existingDrwNos = new Set(lottoData.map(d => d.drwNo));
            let failedAttempts = 0;
            const maxAttempts = 5;
            let latestFound = latestStored;

            for (let i = latestStored + 1; i <= maxDrwNo; i++) {
                if (!existingDrwNos.has(i)) {
                    const data = await fetchLottoData(i);
                    if (data) {
                        lottoData.push(data);
                        existingDrwNos.add(i);
                        latestFound = i;
                        failedAttempts = 0;
                    } else {
                        failedAttempts++;
                        if (failedAttempts >= maxAttempts) break;
                    }
                }
                await new Promise(resolve => setTimeout(resolve, 3000));
            }

            lottoData.sort((a, b) => a.drwNo - b.drwNo);
            localStorage.setItem('lottoData', JSON.stringify(lottoData));
            displayLottoData();
            alert(`최신 회차(${latestFound})까지 업데이트 완료!`);
        }

        // 빈도 분석
        function analyzeFrequency() {
            const lottoList = document.getElementById('lottoList');
            lottoList.innerHTML = '<p>Analyzing Number Frequency...</p>';
            if (currentChart) currentChart.destroy();

            const frequency = Array(45).fill(0);
            lottoData.forEach(entry => entry.numbers.forEach(num => frequency[num - 1]++));

            const canvas = document.createElement('canvas');
            lottoList.appendChild(canvas);
            currentChart = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: Array.from({ length: 45 }, (_, i) => i + 1),
                    datasets: [{ label: 'Frequency', data: frequency, backgroundColor: 'rgba(0, 247, 255, 0.6)', borderColor: 'rgba(0, 247, 255, 1)', borderWidth: 1 }]
                },
                options: { indexAxis: 'y', scales: { x: { beginAtZero: true } } }
            });
        }

        // 짝수/홀수 분석
        function analyzeEvenOdd() {
            const lottoList = document.getElementById('lottoList');
            lottoList.innerHTML = '<p>Analyzing Even/Odd Distribution...</p>';
            if (currentChart) currentChart.destroy();

            const distribution = { '0:6': 0, '1:5': 0, '2:4': 0, '3:3': 0, '4:2': 0, '5:1': 0, '6:0': 0 };
            lottoData.forEach(entry => {
                const evenCount = entry.numbers.filter(num => num % 2 === 0).length;
                distribution[`${evenCount}:${6 - evenCount}`]++;
            });

            const canvas = document.createElement('canvas');
            lottoList.appendChild(canvas);
            currentChart = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: Object.keys(distribution),
                    datasets: [{ label: 'Even:Odd', data: Object.values(distribution), backgroundColor: 'rgba(255, 0, 204, 0.6)', borderColor: 'rgba(255, 0, 204, 1)', borderWidth: 1 }]
                },
                options: { scales: { y: { beginAtZero: true } } }
            });
        }

        // 합계 분석
        function analyzeSum() {
            const lottoList = document.getElementById('lottoList');
            lottoList.innerHTML = '<p>Analyzing Sum Distribution...</p>';
            if (currentChart) currentChart.destroy();

            const sums = lottoData.map(entry => entry.numbers.reduce((a, b) => a + b, 0));
            const bins = Array(26).fill(0);
            sums.forEach(sum => {
                const bin = Math.min(Math.floor((sum - 21) / 10), 25);
                bins[bin]++;
            });

            const canvas = document.createElement('canvas');
            lottoList.appendChild(canvas);
            currentChart = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: Array.from({ length: 26 }, (_, i) => `${21 + i * 10}-${30 + i * 10}`),
                    datasets: [{ label: 'Sum', data: bins, backgroundColor: 'rgba(0, 255, 204, 0.6)', borderColor: 'rgba(0, 255, 204, 1)', borderWidth: 1 }]
                },
                options: { scales: { y: { beginAtZero: true } } }
            });
        }

        // 범위 분석
        function analyzeRange() {
            const lottoList = document.getElementById('lottoList');
            lottoList.innerHTML = '<p>Analyzing Range Distribution...</p>';
            if (currentChart) currentChart.destroy();

            const ranges = { low: 0, mid: 0, high: 0 };
            lottoData.forEach(entry => {
                entry.numbers.forEach(num => {
                    if (num <= 15) ranges.low++;
                    else if (num <= 30) ranges.mid++;
                    else ranges.high++;
                });
            });

            const canvas = document.createElement('canvas');
            lottoList.appendChild(canvas);
            currentChart = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: ['Low (1-15)', 'Mid (16-30)', 'High (31-45)'],
                    datasets: [{ label: 'Range', data: [ranges.low, ranges.mid, ranges.high], backgroundColor: ['rgba(0, 247, 255, 0.6)', 'rgba(255, 0, 204, 0.6)', 'rgba(0, 255, 204, 0.6)'], borderColor: ['rgba(0, 247, 255, 1)', 'rgba(255, 0, 204, 1)', 'rgba(0, 255, 204, 1)'], borderWidth: 1 }]
                },
                options: { scales: { y: { beginAtZero: true } } }
            });
        }

        // 연속 숫자 분석
        function analyzeConsecutive() {
            const lottoList = document.getElementById('lottoList');
            lottoList.innerHTML = '<p>Analyzing Consecutive Numbers...</p>';
            if (currentChart) currentChart.destroy();

            const consecutiveCounts = Array(6).fill(0);
            lottoData.forEach(entry => {
                const sorted = [...entry.numbers].sort((a, b) => a - b);
                let count = 0;
                for (let i = 1; i < sorted.length; i++) {
                    if (sorted[i] - sorted[i - 1] === 1) count++;
                }
                consecutiveCounts[count]++;
            });

            const canvas = document.createElement('canvas');
            lottoList.appendChild(canvas);
            currentChart = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: ['0 Pairs', '1 Pair', '2 Pairs', '3 Pairs', '4 Pairs', '5 Pairs'],
                    datasets: [{ label: 'Consecutive', data: consecutiveCounts, backgroundColor: 'rgba(255, 0, 204, 0.6)', borderColor: 'rgba(255, 0, 204, 1)', borderWidth: 1 }]
                },
                options: { scales: { y: { beginAtZero: true } } }
            });
        }

        // 기본 추천 번호
        function recommendNumbers() {
            const lottoList = document.getElementById('lottoList');
            lottoList.innerHTML = '<p>Basic Number Recommendation...</p>';
            if (currentChart) currentChart.destroy();

            const frequency = Array(45).fill(0);
            lottoData.forEach(entry => entry.numbers.forEach(num => frequency[num - 1]++));

            const recommended = frequency.map((freq, idx) => ({ num: idx + 1, freq }))
                .sort((a, b) => b.freq - a.freq)
                .slice(0, 10)
                .map(item => item.num);

            const div = document.createElement('div');
            div.className = 'recommendation';
            div.textContent = `Top 10 Numbers: ${recommended.join(', ')}`;
            lottoList.appendChild(div);
        }

        // 고급 분석 및 추천
        function advancedAnalysis() {
            const lottoList = document.getElementById('lottoList');
            lottoList.innerHTML = '<p>Advanced Analysis Running...</p>';
            if (currentChart) currentChart.destroy();

            if (lottoData.length === 0) {
                lottoList.textContent = '데이터가 필요합니다.';
                return;
            }

            const frequency = Array(45).fill(0);
            lottoData.forEach(entry => entry.numbers.forEach(num => frequency[num - 1]++));
            const totalFreq = frequency.reduce((a, b) => a + b, 0);
            const weights = frequency.map(f => f / totalFreq);

            const simCount = 1000;
            const simFreq = Array(45).fill(0);
            for (let i = 0; i < simCount; i++) {
                const simNumbers = weightedRandomSample(weights, 6);
                simNumbers.forEach(num => simFreq[num - 1]++);
            }

            const clusters = simpleKMeans(3);
            const clusterFreq = clusters.map(cluster => {
                const freq = Array(45).fill(0);
                cluster.forEach(nums => nums.forEach(num => freq[num - 1]++));
                return freq;
            });

            const combinedFreq = simFreq.map((f, i) => f + clusterFreq.reduce((sum, cf) => sum + cf[i], 0));
            const topNumbers = combinedFreq
                .map((freq, idx) => ({ num: idx + 1, freq }))
                .sort((a, b) => b.freq - a.freq)
                .slice(0, 10)
                .map(item => item.num);

            const div = document.createElement('div');
            div.className = 'recommendation';
            div.textContent = `Advanced Recommendation: ${topNumbers.join(', ')}`;
            lottoList.appendChild(div);

            const canvas = document.createElement('canvas');
            lottoList.appendChild(canvas);
            currentChart = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: Array.from({ length: 45 }, (_, i) => i + 1),
                    datasets: [{ label: 'Simulated Frequency', data: simFreq, backgroundColor: 'rgba(0, 247, 255, 0.6)', borderColor: 'rgba(0, 247, 255, 1)', borderWidth: 1 }]
                },
                options: { indexAxis: 'y', scales: { x: { beginAtZero: true } } }
            });
        }

        // 전략 비교
        function compareStrategies() {
            const lottoList = document.getElementById('lottoList');
            lottoList.innerHTML = '<p>Comparing Lotto Strategies...</p>';
            if (currentChart) currentChart.destroy();

            if (lottoData.length === 0) {
                lottoList.textContent = '데이터가 필요합니다.';
                return;
            }

            const frequency = Array(45).fill(0);
            lottoData.forEach(entry => entry.numbers.forEach(num => frequency[num - 1]++));
            const totalFreq = frequency.reduce((a, b) => a + b, 0);
            const weights = frequency.map(f => f / totalFreq);

            const strategies = {
                'Hot Numbers': hotNumbers(frequency),
                'Cold Numbers': coldNumbers(frequency),
                'Pure Random': pureRandom(),
                'Monte Carlo': monteCarlo(weights),
                'Clustering': clusteringNumbers(),
                'Balanced Mix': balancedMix()
            };

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');
            const headerRow = document.createElement('tr');
            ['Strategy', 'Numbers', 'Sum'].forEach(text => {
                const th = document.createElement('th');
                th.textContent = text;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            Object.entries(strategies).forEach(([name, numbers]) => {
                const tr = document.createElement('tr');
                const nameTd = document.createElement('td');
                const numbersTd = document.createElement('td');
                const sumTd = document.createElement('td');
                nameTd.textContent = name;
                numbersTd.textContent = numbers.join(', ');
                sumTd.textContent = numbers.reduce((a, b) => a + b, 0);
                tr.appendChild(nameTd);
                tr.appendChild(numbersTd);
                tr.appendChild(sumTd);
                tbody.appendChild(tr);
            });

            table.appendChild(thead);
            table.appendChild(tbody);
            lottoList.appendChild(table);

            const canvas = document.createElement('canvas');
            lottoList.appendChild(canvas);
            currentChart = new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: Object.keys(strategies),
                    datasets: [{ label: 'Sum', data: Object.values(strategies).map(nums => nums.reduce((a, b) => a + b, 0)), backgroundColor: 'rgba(0, 255, 204, 0.6)', borderColor: 'rgba(0, 255, 204, 1)', borderWidth: 1 }]
                },
                options: { scales: { y: { beginAtZero: true } } }
            });
        }

        // 봇 추천 함수 (정교한 분석, 10개 로또 세트 + 보너스 번호, 시각화 포함)
        function botRecommend() {
            const botOutput = document.getElementById('botOutput');
            const loadingBar = document.getElementById('loadingBar');
            const loadingProgress = document.getElementById('loadingProgress');

            if (lottoData.length === 0) {
                botOutput.innerHTML = '<p>데이터가 필요합니다.</p>';
                return;
            }

            // 로딩 바 표시
            botOutput.innerHTML = '<p>Analyzing with Enhanced Algorithm...</p>';
            loadingBar.style.display = 'block';
            loadingProgress.style.width = '0';

            // 로딩 애니메이션
            setTimeout(() => {
                loadingProgress.style.width = '100%';
            }, 100);

            // 2초 후 분석 완료 및 결과 표시
            setTimeout(() => {
                const frequency = Array(45).fill(0);
                lottoData.forEach(entry => entry.numbers.forEach(num => frequency[num - 1]++));
                const totalFreq = frequency.reduce((a, b) => a + b, 0);
                const weights = frequency.map(f => f / totalFreq);

                // 과거 데이터 패턴 분석
                const pastSums = lottoData.map(entry => entry.numbers.reduce((a, b) => a + b, 0));
                const avgSum = pastSums.reduce((a, b) => a + b, 0) / pastSums.length;
                const sumRange = lottoData.length < 50 ? [80, 200] : [100, 180]; // 데이터 부족 시 범위 확장

                botOutput.innerHTML = '';
                const recommendedSets = new Set(); // 중복 방지
                const allNumbersFreq = Array(45).fill(0); // 시각화용 빈도
                let attempts = 0;

                while (recommendedSets.size < 10 && attempts < 100) { // 최대 100번 시도
                    const candidate = weightedRandomSample(weights, 7); // 6개 + 보너스 1개
                    const mainNumbers = candidate.slice(0, 6).sort((a, b) => a - b);
                    const bonusNumber = candidate[6];
                    const sum = mainNumbers.reduce((a, b) => a + b, 0);
                    const evenCount = mainNumbers.filter(n => n % 2 === 0).length;
                    const oddCount = 6 - evenCount;
                    const consecutive = countConsecutive(mainNumbers);
                    const ranges = countRanges(mainNumbers);

                    // 필터링 조건: 합계, 짝수/홀수, 연속 번호, 범위 균형
                    if (sum >= sumRange[0] && sum <= sumRange[1] && 
                        evenCount >= 2 && evenCount <= 4 && 
                        consecutive <= 2 && 
                        ranges.low >= 1 && ranges.mid >= 1 && ranges.high >= 1) {
                        const setString = mainNumbers.join(',');
                        if (!recommendedSets.has(setString)) {
                            recommendedSets.add(setString);
                            const div = document.createElement('div');
                            div.className = 'recommendation';
                            div.textContent = `Set ${recommendedSets.size}: ${mainNumbers.join(', ')} (Bonus: ${bonusNumber}, Sum: ${sum}, Even:Odd = ${evenCount}:${oddCount}, Consecutive: ${consecutive})`;
                            botOutput.appendChild(div);
                            mainNumbers.forEach(num => allNumbersFreq[num - 1]++); // 빈도 기록
                        }
                    }
                    attempts++;
                }

                if (recommendedSets.size < 10) {
                    botOutput.innerHTML += '<p>Warning: Could not generate 10 unique sets. Adding random sets...</p>';
                    while (recommendedSets.size < 10) {
                        const fallback = pureRandom();
                        const setString = fallback.join(',');
                        if (!recommendedSets.has(setString)) {
                            recommendedSets.add(setString);
                            const sum = fallback.reduce((a, b) => a + b, 0);
                            const evenCount = fallback.filter(n => n % 2 === 0).length;
                            const oddCount = 6 - evenCount;
                            const consecutive = countConsecutive(fallback);
                            const bonusNumber = Math.floor(Math.random() * 45) + 1;
                            const div = document.createElement('div');
                            div.className = 'recommendation';
                            div.textContent = `Set ${recommendedSets.size} (Fallback): ${fallback.join(', ')} (Bonus: ${bonusNumber}, Sum: ${sum}, Even:Odd = ${evenCount}:${oddCount}, Consecutive: ${consecutive})`;
                            botOutput.appendChild(div);
                            fallback.forEach(num => allNumbersFreq[num - 1]++);
                        }
                    }
                }

                // 추천 번호 빈도 시각화
                const canvas = document.createElement('canvas');
                botOutput.appendChild(canvas);
                new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: Array.from({ length: 45 }, (_, i) => i + 1),
                        datasets: [{ label: 'Recommended Number Frequency', data: allNumbersFreq, backgroundColor: 'rgba(0, 247, 255, 0.6)', borderColor: 'rgba(0, 247, 255, 1)', borderWidth: 1 }]
                    },
                    options: { indexAxis: 'y', scales: { x: { beginAtZero: true } } }
                });

                // 로딩 바 숨기기
                loadingBar.style.display = 'none';
            }, 2000);
        }

        // 연속 번호 카운트 함수
        function countConsecutive(numbers) {
            const sorted = [...numbers].sort((a, b) => a - b);
            let count = 0;
            for (let i = 1; i < sorted.length; i++) {
                if (sorted[i] - sorted[i - 1] === 1) count++;
            }
            return count;
        }

        // 범위 카운트 함수
        function countRanges(numbers) {
            return {
                low: numbers.filter(n => n <= 15).length,
                mid: numbers.filter(n => n > 15 && n <= 30).length,
                high: numbers.filter(n => n > 30).length
            };
        }

        // 전략별 번호 생성 함수
        function hotNumbers(frequency) {
            return frequency.map((freq, idx) => ({ num: idx + 1, freq }))
                .sort((a, b) => b.freq - a.freq)
                .slice(0, 6)
                .map(item => item.num);
        }

        function coldNumbers(frequency) {
            return frequency.map((freq, idx) => ({ num: idx + 1, freq }))
                .sort((a, b) => a.freq - b.freq)
                .slice(0, 6)
                .map(item => item.num);
        }

        function pureRandom() {
            const numbers = new Set();
            while (numbers.size < 6) {
                numbers.add(Math.floor(Math.random() * 45) + 1);
            }
            return Array.from(numbers).sort((a, b) => a - b);
        }

        function monteCarlo(weights) {
            return weightedRandomSample(weights, 6).sort((a, b) => a - b);
        }

        function clusteringNumbers() {
            const clusters = simpleKMeans(3);
            const clusterFreq = Array(45).fill(0);
            clusters.forEach(cluster => {
                cluster.forEach(nums => nums.forEach(num => clusterFreq[num - 1]++));
            });
            return clusterFreq.map((freq, idx) => ({ num: idx + 1, freq }))
                .sort((a, b) => b.freq - a.freq)
                .slice(0, 6)
                .map(item => item.num);
        }

        function balancedMix() {
            const numbers = [];
            const ranges = [[1, 15], [16, 30], [31, 45]];
            ranges.forEach(([min, max]) => {
                for (let i = 0; i < 2; i++) {
                    let num;
                    do {
                        num = Math.floor(Math.random() * (max - min + 1)) + min;
                    } while (numbers.includes(num));
                    numbers.push(num);
                }
            });
            return numbers.sort((a, b) => a - b);
        }

        function weightedRandomSample(weights, count) {
            const result = new Set();
            while (result.size < count) {
                let rand = Math.random();
                let cumulative = 0;
                for (let i = 0; i < weights.length; i++) {
                    cumulative += weights[i];
                    if (rand <= cumulative) {
                        result.add(i + 1);
                        break;
                    }
                }
            }
            return Array.from(result);
        }

        function simpleKMeans(k) {
            const data = lottoData.map(entry => entry.numbers);
            if (data.length < k) return [data];
            const centroids = data.slice(0, k);
            for (let iter = 0; iter < 10; iter++) {
                const clusters = Array(k).fill().map(() => []);
                data.forEach(numbers => {
                    const distances = centroids.map(c => euclideanDistance(c, numbers));
                    const closest = distances.indexOf(Math.min(...distances));
                    clusters[closest].push(numbers);
                });
                centroids.forEach((_, i) => {
                    if (clusters[i].length > 0) {
                        centroids[i] = averageNumbers(clusters[i]);
                    }
                });
            }
            return clusters.filter(c => c.length > 0);
        }

        function euclideanDistance(a, b) {
            return Math.sqrt(a.reduce((sum, ai, i) => sum + (ai - b[i]) ** 2, 0));
        }

        function averageNumbers(cluster) {
            const len = cluster.length;
            return cluster[0].map((_, i) => Math.round(cluster.reduce((sum, nums) => sum + nums[i], 0) / len));
        }

        // 페이지 로드
        window.onload = () => {
            displayLottoData();
            updateLatestLotto();
            setInterval(updateLatestLotto, 7 * 24 * 60 * 60 * 1000); // 7일마다 업데이트
        };
    </script>
</body>
</html>
